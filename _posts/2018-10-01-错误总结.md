---
layout:		post
title:		错误总结
editdate:	2020-08-10
date:		2018-10-01
author:		wyj
catalog:	true
tags:
    - OI
    - 总结
---

{:c:.Z .language-cpp}

效仿[LZQ巨佬](https://www.luogu.com.cn/blog/Re-see/)和[YS神仙](https://blog.csdn.net/emmmmmmmmm)。

亡羊补牢。

-----
# 关键
maxn千万不要开小了

循环变量中的`i`和`j`千万不能搞混

从0开始编号和从1开始编号之间一定要记得++,--

各种上下界，分清0和1。0经常要特判

-1什么的认真看题

gen注意srand

一定要认真体会贡献提前和推后计算的思想

线段树递归边界中是`a[p]=v`{:c},不是`a[x]=v`{:c}。我因为这个经常调一年。

多组数据时一定要清零：最关键的不是清那些dis、vis这样显然要清的数组，而是**隐含着使用了某些未赋值的位是零条件的数组**，比如后缀数组的rnk和**nrnk(这个比较隐蔽)**

**尽量不要覆盖已有的关键程序（保持警惕）**

不要把x和`dfn[x]`{:c}、`pos[x]`{:c}之类混淆。我因为这个经常调一年。

powl和sqrt需要进行微调，**无论如何都需要**

在NOI Linux等等环境中尽量不要使用初始化列表，尽量用列表初始化。

# 卡常技巧

卡常时最有效果的是交换循环顺序和减少取模，其它都是吹出来的，这个是历久不变的真理。

网络流不建流不了的点可以优化常数，同样的，**很多图论问题建隐式图可以大量优化常数**

线段树前缀修改 / 查询比区间操作快一倍，卡常时可以考虑一下。

如果可以用map尽量用map，因为毒瘤出题人会卡unordered_map

不能开超过一百万个vector或者basic_string，否则又TLE又MLE

欧拉序不要把每个叶子记录两次

离散化不能用lower_bound，应该把编号带进去排序

# 字符串
`fgets()`{:c}不要忘了末尾可能有换行，最好不要用。

注意SA中添加进去的字符应该算入存储空间，并且**两两不能相同**

记得把nrnk拷贝回rnk,两个分分清楚。

# BM

人生第一次写BM调试了一年。。。。这东西的细节密度（细节/代码长度）是我写过的所有算法中最多的，每一个字符都暗藏着陷阱。。。
- 递推式更新时长度应该是取max而不是赋值成$i+1-l_i$，因为就算更新了也可能是原来的数列更长，因为递推式可能有最高次为0的情况。
- 仅当存在$p$的时候需要更新递推式，$p$不存在时简单地增加$l$即可。递推式最高次为0是合法的。
- 每次询问$l$的时候都需要特判$-1$的情况，因为即使存在$p$也可能访问到$l=-1$ 的位置。
- 每次改变$p$时，变成$R_{p-1}$的应该是$R_{i-1}$而不是$R_i$。由于这个互相依赖的关系，需要开一个临时数组存放$R_{i-1}$。
- 只有长度更新**而不是递推式更新**时才应该改变$p$和$c$。这点真的很难看出来，因为按照“递推式更新时修改”的方法做，**是符合论文里给出的任何一个式子的**。然而有一个隐式的条件叫做$S$的次数一定要严格小于$R$的次数，否则会推翻之前成立的结果。可以发现当长度不变时，新的$S$的次数最多可以恰巧与$R$相等，所以会假。

-----
注意有重复时使用multiset。

计算几何注意凸包可能只有一两个点（**毒瘤题甚至可能没有点**），注意eps。半平面交可能只有一条直线。

数位dp注意前导零。如果觉得已经注意了，就再注意一下。

RMQ右端点记得+1。比如说用sa的时候，可以把height数组整体左移一位，结合RMQ的+1会让代码简洁得多。

快速幂的参数是ll。传入参数的时候千万千万要记得先取模再传进去。幂次不能为负（如果你把它对$\varphi(p)$取模了）。

无论什么离散化/排序，最好不要用sa和rnk数组，带着id放在结构体里一起排序。因为前面两个不一定能保持不变。

FFT精度要求高不要三遍变两遍

可能爆ll的时候多多留神，尽量避免__int128。有条件的时候记得开`-fsanitize=undefined`测一下（NOI Linux下用`-ftrapv -fsanitize=address`）。

多多考虑inf是否够大，比如说网络流经常会涉及到不同级别的inf。同时调整inf大小的时候不要忘了把int改成ll（或者相反）。

分类时要确保对所有的类做了该做的全部操作，千万不能图方便简写。多写几个if不会死人的。可以换一个角度，用面向侧面的思维分析。同时也要确保同一个操作不要脑抽写了多次。

并查集连边时是`fa[fa[u]]=fa[v]`{:c},不是`fa[u]=v`{:c}.

主席树不能修改，只能新建

空集不等于什么都没有

C++中除法向零取整，负数时可能有问题，经常需要写一个特判。

平衡树不是线段树，update时要考虑当前节点自己的信息（不只是左右儿子）。

图可能不连通，不能只执行一个`dfs(1)`{:c}。

dp中f[n]可能不是最后的答案，因为不一定要选最后一个

`#include<bits/extc++.h>`{:c}时应该同时`#include<bits/stdc++.h>`{:c}

注意快速幂时底数可能也需要取模

在C++11环境下必须`namespace std`{:c}里声明特化hash

AC自动机上统计一个点结尾的**所有**子串相关信息时千万不要忘了跳fail树

`scanf()`{:c}记得%c、%s格式前的空格

long double可能占16byte

分清x和y的意义

并查集和LCT都要把数据结构中连的边和真正的边分清楚。

线段树注意空间，普通的`<<2`，动态的`* 31`，主席树能开多大开多大，千万不要忘记`#pragma pack(1)`{:c};
# $$\Huge\text{拒绝TJ从我做起}$$
